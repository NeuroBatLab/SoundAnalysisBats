function [Unmerged, Merged] = voc_localize_using_piezo(Logger_dir,RawWav_dir, Date, ExpStartTime)
%% VOC_LOCALIZE_USING_PIEZO a function to detect vocalizations based on threshold crossing in piezo recordings
%% and classification with an SVM trained on a groundtruth dataset
%% This function also retrieves the position of these extracts in continuous microphone recordings
%% for MOTU recordings with vocOperant
%% Depends on SVMModelNoiseVoc.mat in \SoundAnalysisBats\

% Inputs
% Logger_dir is the folder containing the logger folders containing the
% extracted/CS0.mat files

% RawWav_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
%  in case calculating microphone time is requested. If left empty, only
%  logger data are calculated. Retrieval of mic data is currently only working for data
% collected with vocOperant (MOTU) and TTL pulses synchronization, and requires running
% align_soundmexAudio_2_logger.m before. Note that if you use microphone
% data, then vocalizations detected on loggers outside of microphone
% recording times will not be kept


% Ouputs: 2 structures that contain the same fields detailed below. Unmerged: results
% before sound element merge; Merged: results after merge of sound elements
% within Merge_thresh. Merge_thresh is hard coded at 500ms,to facilitate
% the data curation with who calls.

% Voc_loggerSamp_idx is a 2 column vector that gives the onset and offset indices
% of each extract in the original logger recordings (CS0.mat files).

% Voc_transc_time is a 2 column vector that gives the expected onset and offest
% times of each extract in the piezo logger recordings in transceiver time,
% in ms
% same number of lines as Voc_filename.

% Logger_ID is a cell array of the logger# on which each event has been detected. Note that
% after merge of vocalizations, the LoggerID of the first sound event in
% the sequence is taken as a reference.

% FS_logger_voc is a 1 column vector of the true sampling frequency for
% each detected sound element


if nargin<2
    MicData=0;
else
    MicData=1;
end


Merge_thresh = 500; % merge thershold in ms for grouping sounds in sequences if they are withinh that delay
if MicData
    if ~exist(fullfile(RawWav_dir, 'Detected_calls'),'dir')
        mkdir(fullfile(RawWav_dir, 'Detected_calls'))
    end
    FS_raw = 192000;%Frequency of the microphone recordings, here MOTU as default
    % Hard coded input for finding the microphone envelope noise threshold
    Dur_RMS = 0.5; % duration of the silence sample in min for the calculation of average running RMS
    Fhigh_power = 20; %Hz
    Fs_env = 1000; %Hz Sample frequency of the enveloppe
    Fresample = 40000;% resampling frequency for the calculation of cross correlation between piezo and microphone for better classifying calls
    MicThreshNoise = 15*10^-3;
end



%% Load data and initialize output variables
if MicData
    % Load the pulse times and samples
    TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
    TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
    
    % check the number of files
    WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*.wav',Date, ExpStartTime)));
    NRawWave = length(WavFileStruc_local);
    
end

%% Run the automatic detection
AllLoggers = dir(fullfile(Logger_dir, '*ogger*'));
DirFlags = [AllLoggers.isdir];
% Extract only those that are directories.
AllLoggers = AllLoggers(DirFlags);
% Identify audio loggers
NLogger = length(AllLoggers);
% Identify the type of logger and initialize output variables
LoggerTypeAudi = zeros(NLogger,1);
for ll=1:NLogger
    LDir = dir(fullfile(AllLoggers(ll).folder,AllLoggers(ll).name, 'extracted_data', '*CSC*.mat'));
    LData = load(fullfile(LDir(1).folder, LDir(1).name), 'logger_type', 'logger_serial_number');
    LoggerTypeAudi(ll)  = strcmp(LData.logger_type, 'Audi');
end
AllLoggers = AllLoggers(logical(LoggerTypeAudi));


% Loop through loggers and detect vocalizations based on thereshold
% crossings on the envelope
NL = length(AllLoggers);
Nevents = nan(NL,1);
SoundEvent_LoggerSamp = cell(NL,1);
SoundEvent_TranscTime_ms = cell(NL,1);
ALField_Id = cell(NL,1);% Names of the audioLoggers
for ll=1:NL
    fprintf(1,'Envelope calculations %s, %d/%d\n',AllLoggers(ll).name, ll, NL)
    Data_directory = fullfile(AllLoggers(ll).folder,AllLoggers(ll).name, 'extracted_data');
    ALField_Id{ll} = sprintf('L%s',AllLoggers(ll).name(2:end));
    [SoundEvent_LoggerSamp{ll},SoundEvent_TranscTime_ms{ll},~,~,~] = piezo_find_calls_logger(Data_directory);
    Nevents(ll) = size(SoundEvent_LoggerSamp{ll},1);
end

% Sort vocalization from noise using an SVM approach on acoustic parameters
Buffer = 30;% time in ms to add before after each sound element such atht it's longer than the 23ms required for biosound to calculate fundamental and saliency parameters and longer than 60ms for running RMS to calculate the envelope
F_high = 5000; % frequency low pass on the logger detected sounds for calculating temporal acoustic features and Saliency
F_low = 100;% frequency high pass n the logger detected sounds
F_highSpec = 15000;% frequency low pass on the logger detected sounds for calculating spectral parameters
AcousticParams = cell(1,NL);
LoggerID_unmerged = cell(1,NL);
FS_logger_voc_unmerged = cell(1,NL);
Voc_loggerSamp_Idx_unmerged = cell(1,NL);
Voc_transc_time_unmerged = cell(1,NL);
if MicData
    % bandpass filters on microphone and logger data to calculate the cross
    % correlation value
    Flow = 500;
    FHigh = 10000;
    [z,p,k] = butter(6,[Flow FHigh]/(FS_raw/2),'bandpass');
    sos_mic_band = zp2sos(z,p,k);
    [z,p,k] = butter(6,[Flow FHigh]/(50000/2),'bandpass');
    sos_logger_band = zp2sos(z,p,k);
end
    
    
parfor ll=1:NL % parfor
    fprintf(1, '*** Sort Voc from Noise %s %d/%d ****\n',ALField_Id{ll}, ll, NL)
    if Nevents(ll)==0
        fprintf(1,'No voc detected for %s %d/%d ****\n',ALField_Id{ll}, ll, NL)
    else
        % Load the raw signal
        Data_directory = fullfile(AllLoggers(ll).folder,AllLoggers(ll).name, 'extracted_data');
        File = dir(fullfile(Data_directory, '*CSC0*'));
        if isempty(File)
            error('Data file not found');
        end
        Filepath = fullfile(File.folder, File.name);
        Data=load(Filepath, 'AD_count_int16', 'Indices_of_first_and_last_samples','Estimated_channelFS_Transceiver');
        % Center the signal and clear the old data from memory
        Centered_piezo_signal = double(Data.AD_count_int16) - mean(double(Data.AD_count_int16));
        Data.AD_count_int16 = [];

        if MicData
            % convert transceiver time to audio samp files
            [MVSI,MVF]=transc_time2micsamp(RawWav_dir,Date, ExpStartTime,SoundEvent_TranscTime_ms{ll});
            OldMicVoc_File = 0;
        end
        % Loop through sound events

        FS_logger_voc_unmerged{ll} = nan(1,Nevents(ll));
        if MicData
            AcousticParams{ll} = nan(20,Nevents(ll));
        else
            AcousticParams{ll} = nan(16,Nevents(ll));
        end
        LoggerID_unmerged{ll} = cell(1,Nevents(ll));
        Voc_loggerSamp_Idx_unmerged{ll} = nan(2,Nevents(ll));
        Voc_transc_time_unmerged{ll} = nan(2,Nevents(ll));

        % Loop through sound events
        for ee=1:Nevents(ll)
            if rem(ee,100)==0
                fprintf(1, 'Event %d/%d\n', ee,Nevents(ll))
            end
            % Onset and offset of detected sound extract
            OnInd = SoundEvent_LoggerSamp{ll}(ee,1);
            OffInd = SoundEvent_LoggerSamp{ll}(ee,2);
            % find the sampling Frequency
            FileIdx = find((Data.Indices_of_first_and_last_samples(:,1)<OnInd) .* (Data.Indices_of_first_and_last_samples(:,2)>OffInd));
            if isempty(FileIdx) || (length(FileIdx)~=1) || FileIdx>length(Data.Estimated_channelFS_Transceiver)
                FS_logger_voc_unmerged{ll}(ee) = round(nanmean(Data.Estimated_channelFS_Transceiver));
            else
                FS_logger_voc_unmerged{ll}(ee) = round(Data.Estimated_channelFS_Transceiver(FileIdx));
                if isnan(FS_logger_voc_unmerged{ll}(ee))
                    FS_logger_voc_unmerged{ll}(ee) = round(nanmean(Data.Estimated_channelFS_Transceiver));
                end

            end

            % extract the sound with Buffer ms before after the sound
            OnIndBuff = OnInd - round(FS_logger_voc_unmerged{ll}(ee)*Buffer*10^-3);
            OffIndBuff = OffInd + round(FS_logger_voc_unmerged{ll}(ee)*Buffer*10^-3);
            if OnIndBuff<=0
                OffIndBuff = OffIndBuff - OnIndBuff;
                OnIndBuff = 1;
            end
            if OffIndBuff>length(Centered_piezo_signal)
                OnIndBuff = OnIndBuff - (OffIndBuff - length(Centered_piezo_signal));
                OffIndBuff = length(Centered_piezo_signal);
            end
            Logger_Sound = Centered_piezo_signal(OnIndBuff : OffIndBuff);
            Logger_Sound = Logger_Sound - mean(Logger_Sound);
            try
                [AcousticParams_temp,~] = run_acoustic_features(Logger_Sound, FS_logger_voc_unmerged{ll}(ee), 'F_high',F_high, 'F_low', F_low, 'F_highSpec',F_highSpec);
            catch ME
                if strfind(ME.message, 'The signal is too short to calculate an enveloppe with such a low frequency for the low-pass filter on signal power')
                    warning('The signal is too short to calculate an enveloppe with such a low frequency for the low-pass filter on signal power\nskip that data, probably noise!\n')
                end
                continue
            end
            AcousticParams{ll}(1:length(AcousticParams_temp),ee) = AcousticParams_temp';
            LoggerID_unmerged{ll}{ee} = ALField_Id{ll};
            Voc_loggerSamp_Idx_unmerged{ll}(:,ee) = [OnInd; OffInd];
            Voc_transc_time_unmerged{ll}(:,ee) = SoundEvent_TranscTime_ms{ll}(ee,:)';

            if MicData
                % Add parameters regarding the microphone data
                if OldMicVoc_File~=MVF(ee)
                    RawWavDir = dir(fullfile(RawWav_dir,sprintf('*%s_%s_RecOnly*mic1_%d.wav',Date, ExpStartTime,MVF(ee))));
                    [RawWav_mic, FS_mic] = audioread(fullfile(RawWavDir.folder, RawWavDir.name));
                    OldMicVoc_File = MVF(ee);
                end
                mic_start = round(MVSI(ee,1)-Buffer*FS_mic*10^-3);
                mic_stop = round(MVSI(ee,2)+Buffer*FS_mic*10^-3);
                if mic_start<0 || mic_stop<0% call occur before microphone started recording
                    continue
                end

                if length(RawWav_mic)>mic_start
                    % all ggod to go check mic_stop below
                elseif length(RawWav_mic)<=mic_start && (MVF(ee)==NRawWave)
                    % This event happened after the offset of microphone, discard
                    fprintf(1, 'This call occured after microphone offset\n')
                    continue
                else% there was an error in the estimation of the file index, this call occured in the next file
                    fprintf(1, 'This call occured in next file\n')
                    MVF(ee) = MVF(ee)+1;

                    % Calculate the Samples of the extract in the microphone recording
                    TTL_idx = find(unique(TTL.File_number) == MVF(ee));
                    if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
                        continue
                    else
                        Voc_transc_time_zs = (SoundEvent_TranscTime_ms{ll}(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
                        mic_start_stop = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
                        mic_start = mic_start_stop(1);
                        mic_stop = mic_start_stop(2);
                    end

                    if MVF(ee) ~= OldMicVoc_File
                        RawWavDir = dir(fullfile(RawWav_dir,sprintf('*%s_%s_RecOnly*mic1_%d.wav',Date, ExpStartTime,MVF(ee))));
                        [RawWav_mic, FS_mic] = audioread(fullfile(RawWavDir.folder, RawWavDir.name));
                        OldMicVoc_File = MVF(ee);
                    end
                end

                if mic_stop>length(RawWav_mic) % this section is cut between 2 10 min recordings
                    mic_stop1 = length(RawWav_mic);
                    mic_stop2 = mic_stop - length(RawWav_mic);
                    RawWavDir2 = dir(fullfile(RawWav_dir,sprintf('*%s_%s_RecOnly*mic1_%d.wav',Date,ExpStartTime,MVF(ee)+1)));
                    if ~isempty(RawWavDir2) 
                        [RawWav_local2, FS_mic] = audioread(fullfile(RawWavDir2.folder, RawWavDir2.name));
                        if mic_stop2>length(RawWav_local2)
                            % this is an unexpectedly very long extract!!
                            warning('this is an unexpectedly very long extract!!')
                            keyborad
                        end
                        Mic_Sound = [RawWav_mic(mic_start:mic_stop1); RawWav_local2(1:mic_stop2)];
                        RawWav_mic = RawWav_local2;
                        RawWav_local2 = [];
                        OldMicVoc_File = MVF(ee)+1;
                        
                    else % that was the last recording from the microphone
                        if mic_start>length(RawWav_mic) % call occur after microphone stopped recording
                            continue
                        end
                        Mic_Sound = RawWav_mic(mic_start:mic_stop1);
                    end
                elseif mic_start<0 || mic_stop<0
                    % This call occured in between 2 file recordings!
                    fprintf(1, 'This call occured in between 2 file recordings!\n')
                    continue
                else
                    Mic_Sound = RawWav_mic(mic_start:mic_stop);
                end
                % filter the data
                Mic_Sound = Mic_Sound-mean(Mic_Sound);
                Filt_MicData = filtfilt(sos_mic_band,1,Mic_Sound);
                Filt_LoggerData = filtfilt(sos_logger_band,1,Logger_Sound);
                % Calculate the RMS in the microphone extract and check if it's
                % above thershold
                AmpEnv=envelope(Filt_MicData,FS_mic/Fs_env,'rms');
                AcousticParams{ll}(17,ee)=std(Filt_MicData(Filt_MicData~=0));
                AcousticParams{ll}(18,ee) = max(AmpEnv);
                AcousticParams{ll}(19,ee) = mean(AmpEnv);
                ResampFilt_MicData = resample(Filt_MicData,Fresample,FS_mic);
                ResampFilt_LogData = resample(Filt_LoggerData,Fresample,FS_logger_voc_unmerged{ll}(ee));
                if length(ResampFilt_MicData)~=length(ResampFilt_LogData)
                    OptLength = min(length(ResampFilt_MicData),length(ResampFilt_LogData));
                    ResampFilt_MicData = ResampFilt_MicData(1:OptLength);
                    ResampFilt_LogData = ResampFilt_LogData(1:OptLength);
                end
                % Do a cross correlation between the two signals
                [Xcor,~] = xcorr(ResampFilt_MicData,ResampFilt_LogData, (2*Buffer*10^-3)*Fresample,'normalized'); % Running a cross correlation between the raw signal and each audio logger signal with a maximum lag equal to twice the Buffer size
                AcousticParams{ll}(20,ee) = max(abs(Xcor));

            end
        end
    end
end

% Concatenate the results and set rows to be observations
AcousticParams = [AcousticParams{:}]';
LoggerID_unmerged = [LoggerID_unmerged{:}]';
Voc_loggerSamp_Idx_unmerged = [Voc_loggerSamp_Idx_unmerged{:}]';
Voc_transc_time_unmerged = [Voc_transc_time_unmerged{:}]';
FS_logger_voc_unmerged = [FS_logger_voc_unmerged{:}]';
% restrict data to only those that were correctly processed (long enough)
DataSet = ~isnan(AcousticParams(:,1));
AcousticParams = AcousticParams(DataSet,:);
LoggerID_unmerged = LoggerID_unmerged(DataSet);
Voc_loggerSamp_Idx_unmerged = Voc_loggerSamp_Idx_unmerged(DataSet,:);
Voc_transc_time_unmerged = Voc_transc_time_unmerged(DataSet,:);
FS_logger_voc_unmerged = FS_logger_voc_unmerged(DataSet);

if MicData
    % restrict data to only those that have microphone data
    DataSet = ~isnan(AcousticParams(:,20));
    AcousticParams = AcousticParams(DataSet,:);
    LoggerID_unmerged = LoggerID_unmerged(DataSet);
    Voc_loggerSamp_Idx_unmerged = Voc_loggerSamp_Idx_unmerged(DataSet,:);
    Voc_transc_time_unmerged = Voc_transc_time_unmerged(DataSet,:);
    FS_logger_voc_unmerged = FS_logger_voc_unmerged(DataSet);
end


% Load the SVM compact model, predict labels according to the model and
% eliminate noise
Path2SVM = fileparts(which('voc_localize_using_piezo.m'));
if MicData
    load(fullfile(Path2SVM,'SVMModelNoiseVoc_MicLog.mat'),'CompactSVMModel')
else
    load(fullfile(Path2SVM,'SVMModelNoiseVoc.mat'),'CompactSVMModel')
end
[~,PostProbs] = predict(CompactSVMModel,AcousticParams);
Labels = PostProbs(:,2)>=2*10^-3; % Here we are being very conservative and keep events that even have a slight chance of being vocalizations

fprintf(1, 'Eliminating %d/%d elements detected as noise\n', sum(~Labels), length(Labels))
% Select presume vocalizations and order them in time
LoggerID_unmerged = LoggerID_unmerged(logical(Labels));
Voc_loggerSamp_Idx_unmerged = Voc_loggerSamp_Idx_unmerged(logical(Labels),:);
Voc_transc_time_unmerged = Voc_transc_time_unmerged(logical(Labels),:);
FS_logger_voc_unmerged = FS_logger_voc_unmerged(logical(Labels));


[~, OrdInd] = sort(Voc_transc_time_unmerged(:,1));
Voc_transc_time_unmerged = Voc_transc_time_unmerged(OrdInd,:);
LoggerID_unmerged = LoggerID_unmerged(OrdInd);
Voc_loggerSamp_Idx_unmerged = Voc_loggerSamp_Idx_unmerged(OrdInd,:);
FS_logger_voc_unmerged = FS_logger_voc_unmerged(OrdInd,:);


%% Merge vocalizations into sequences if they are less than Merge_thresh appart to avoid repetition in Who Calls and add Merge_Thresh before/after
fprintf(1, '***** . Merge sound events within %d ms  *****\n', Merge_thresh)
Events2Merge = [0; (Voc_transc_time_unmerged(2:end,1)-Voc_transc_time_unmerged(1:end-1,2))<= Merge_thresh];
FirstEvents2Merge = find(diff([Events2Merge; 0])==1); % onset of each sequence of events that should be merged
LastEvents2Merge = find(diff([Events2Merge; 0])==-1);% offset of each sequence of events that should be merged
Events2keep = strfind([Events2Merge' 0],[0 0]); % events that should be kept as they are
if length(FirstEvents2Merge)~=length(LastEvents2Merge)
    warning('Problem in the detection of sequences of sound events to merge')
    keyboard
end
Voc_transc_time = [Voc_transc_time_unmerged(Events2keep,:) ; [Voc_transc_time_unmerged(FirstEvents2Merge,1) Voc_transc_time_unmerged(LastEvents2Merge,2)]];
Voc_loggerSamp_Idx = [Voc_loggerSamp_Idx_unmerged(Events2keep,:) ; [Voc_loggerSamp_Idx_unmerged(FirstEvents2Merge,1) Voc_loggerSamp_Idx_unmerged(LastEvents2Merge,2)]]; % After merging, most of these numbers do not make sense anymoire because they refer to different loggers, only the onset does
LoggerID = [LoggerID_unmerged(Events2keep) ; LoggerID_unmerged(FirstEvents2Merge)];% After merging, the ID of the logger is only true for the onset
FS_logger_voc = [FS_logger_voc_unmerged(Events2keep) ; FS_logger_voc_unmerged(FirstEvents2Merge)];


% reorder in time
[~, OrdInd] = sort(Voc_transc_time(:,1));
Voc_transc_time = Voc_transc_time(OrdInd,:);
LoggerID = LoggerID(OrdInd);
Voc_loggerSamp_Idx = Voc_loggerSamp_Idx(OrdInd,:);
FS_logger_voc =FS_logger_voc(OrdInd);


% Add MergeThresh before and after each
Voc_transc_time(:,1) = Voc_transc_time(:,1) - Merge_thresh;
Voc_transc_time(:,2) = Voc_transc_time(:,2) + Merge_thresh;
Voc_loggerSamp_Idx(:,1) = Voc_loggerSamp_Idx(:,1) - Merge_thresh*10^-3.*FS_logger_voc;
Voc_loggerSamp_Idx(:,2) = Voc_loggerSamp_Idx(:,2) + Merge_thresh*10^-3.*FS_logger_voc;

TotEvents_merged = size(Voc_transc_time,1);

%% Retrieve the Microphone file that contains the data for each detected sequence of vocalization if requested
% currently only working for Motu set-ups
if MicData
    fprintf(1, '*****  Retrieve corresponding data in the microphone  *****\n')
    % Construct the frequency bandpass filter for calculating the noise rate on
    % the microphone data
    WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*.wav',Date, ExpStartTime)));
    Raw_filename = fullfile(WavFileStruc_local(1).folder, WavFileStruc_local(1).name);
    Subj = WavFileStruc_local(1).name(1:4);
    Info = audioinfo(Raw_filename);
    FS = Info.SampleRate;
    [z,p,k] = butter(6,[1000 90000]/(FS/2),'bandpass');
    sos_raw_band = zp2sos(z,p,k);
    
    NRawWave = length(WavFileStruc_local);
    MeanStdAmpRawFile = cell(1,NRawWave);
    FileIdx = cell(1,NRawWave);
    
    % Calculate the amplitude threshold as the average amplitude on the
    % first 30 seconds of that 10 min recording file from which that file
    % come from
    % Get the average running rms in a Dur_RMS min extract in the middle of
    % the recording
    % calculate the amplitude threshold for that file
    fprintf(1, 'Calculating average RMS values on a %.1f min sample of silence for each mic file\n',Dur_RMS);
    parfor vv=1:NRawWave %parfor
        % load the raw file
        Raw_filename = fullfile(WavFileStruc_local(vv).folder, WavFileStruc_local(vv).name);
        [Raw_10minwav, FS] = audioread(Raw_filename);
        
        
        SampleDur = round(Dur_RMS*60*FS);
        StartSamp = round(length(Raw_10minwav)/10); % start earlier to make sure we have more potential sections
        fprintf(1,'Calculating the amplitude threshold for file %d/%d  ',vv,NRawWave)
        BadSection = 1;
        IncrementFactor=1;
        while BadSection
            if (StartSamp+round(SampleDur))> length(Raw_10minwav)
                IncrementFactor=IncrementFactor+1;
                StartSamp = 1;
                if (StartSamp+round(SampleDur))> length(Raw_10minwav)
                    % this recording is too short to calculate the
                    % background noise with such a long Sampling Duration
                    warning('short file, bringing down the duration of the sample\n')
                    while (StartSamp+round(SampleDur))> length(Raw_10minwav)
                        SampleDur = SampleDur/2;
                    end
                end
                    
            end
            Filt_RawVoc = filtfilt(sos_raw_band,1,Raw_10minwav(StartSamp + (1:round(SampleDur))));
            Amp_env_Mic = running_rms(Filt_RawVoc, FS, Fhigh_power, Fs_env);
            if any(Amp_env_Mic>MicThreshNoise) % there is most likely a vocalization in this sequence look somewhere else!
                StartSamp = StartSamp + SampleDur/IncrementFactor +1;
            else
                BadSection = 0;
            end
        end
        Ind_ = strfind(WavFileStruc_local(vv).name, '_');
        Ind_ = Ind_(end);
        Indwav = strfind(WavFileStruc_local(vv).name, '.wav');
        FileIdx{vv} = str2double(WavFileStruc_local(vv).name((Ind_+1):(Indwav)));
        MeanStdAmpRawFile{vv} = [mean(Amp_env_Mic); std(Amp_env_Mic)];
        fprintf('-> Done\n')
    end
    MeanStdAmpRawFile = [MeanStdAmpRawFile{[FileIdx{:}]}]';
    
%     MeanStdAmpRawExtract = cell(1,TotEvents_merged);
    Voc_filename = cell(TotEvents_merged,1);
    OldMicVoc_File=0;
    fprintf(1,'Extracting vocalization sequences from microphone and save\n')
    
    % convert transceiver time to audio samp files
    [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir, Date, ExpStartTime,Voc_transc_time);
    MeanStdAmpRawExtract = MeanStdAmpRawFile(MicVoc_File,:);
    
    for ee=1:TotEvents_merged
        fprintf('Saving Voc %d/%d\n', ee, TotEvents_merged)
        
%         % Find the microphone file
%         OnFile = find(TTL.Pulse_TimeStamp_Transc<Voc_transc_time(ee,1),1,'Last');
%         OffFile = find(TTL.Pulse_TimeStamp_Transc>Voc_transc_time(ee,2),1,'First')-1;
%         if isempty(OnFile)
%             % This event occured before the onset of TTL pulses
%             OnFile =1;
%             OffFile=1;
%         elseif isempty(OffFile)
%             % This event occured after the offset of TTL pulses
%             OffFile = OnFile;
%         end
%         FileIdx_local = min(TTL.File_number(OnFile), TTL.File_number(OffFile));
%         
%         
%         MeanStdAmpRawExtract{ee}= MeanStdAmpRawFile(MicVoc_File(ee),:)';
        
        % Calculate the Samples of the extract in the microphone recording
%         TTL_idx = find(unique(TTL.File_number) == FileIdx_local);
%         if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
%             continue
%         else
%             Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
%             Voc_samp_idx{ee} = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
%         end
        
        % Extract the wave from the microphone recording
        if any(MicVoc_samp_idx(ee,:)<0)
            % This vocalization happened before the microphone started
            % recording, discard
            fprintf(1,'Vocalization happened before Mic onset\n')
        else
            if MicVoc_File(ee) ~= OldMicVoc_File
                Raw_10minwav2 = [];
                WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic1_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                [Raw_10minwav2, FS2] = audioread(Raw_filename);
                OldMicVoc_File = MicVoc_File(ee);
            end
            
            if length(Raw_10minwav2)>MicVoc_samp_idx(ee,1)
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
                % Save the sound as a wav file
                Voc_filename{ee} = fullfile(RawWav_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
                audiowrite(Voc_filename{ee} , Raw_wave, FS2)
            elseif (length(Raw_10minwav2)<=MicVoc_samp_idx(ee,1)) && (MicVoc_File(ee)==NRawWave)
                % This event happened after the offset of microphone, discard
                fprintf(1, 'This call occured after microphone offset\n')
                Raw_wave = [];
                continue
            elseif length(Raw_10minwav2)<=MicVoc_samp_idx(ee,1)
                % there was an error in the estimation of the file index, this call occured in the next file
                fprintf(1, 'This call occured in next file\n')
                MicVoc_File(ee) = MicVoc_File(ee)+1;
                MeanStdAmpRawExtract(ee,:)= MeanStdAmpRawFile(MicVoc_File(ee),:)';
                
                % Calculate the Samples of the extract in the microphone recording
                TTL_idx = find(unique(TTL.File_number) == MicVoc_File(ee));
                if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
                    continue
                else
                    Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
                    MicVoc_samp_idx(ee,:) = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
                end
                
                if MicVoc_File(ee) ~= OldMicVoc_File
                   Raw_10minwav2 = [];
                    WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic1_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                    Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                    [Raw_10minwav2, FS2] = audioread(Raw_filename);
                    OldMicVoc_File = MicVoc_File(ee);
                end
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
                % Save the sound as a wav file
                Voc_filename{ee} = fullfile(RawWav_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
                audiowrite(Voc_filename{ee} , Raw_wave, FS2)
            end
            
        end
    end
    
    ActiveVoc = ~cellfun('isempty',Voc_filename);
    Voc_samp_idx = MicVoc_samp_idx(ActiveVoc,:);
    MeanStdAmpRawExtract = MeanStdAmpRawExtract(ActiveVoc,:);
    Voc_filename = Voc_filename(ActiveVoc);
    Voc_transc_time = Voc_transc_time(ActiveVoc,:);
    LoggerID = LoggerID(ActiveVoc);
    Voc_loggerSamp_Idx = Voc_loggerSamp_Idx(ActiveVoc,:);
    FS_logger_voc =FS_logger_voc(ActiveVoc,:);
    MicVoc_File = MicVoc_File(ActiveVoc,:);
end

%% save and return the calculation results
if MicData
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time','MeanStdAmpRawExtract','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File')
else
    save(fullfile(Logger_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_transc_time','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged')
end

Merged.Voc_transc_time = Voc_transc_time;
Merged.LoggerID = LoggerID;
Merged.Voc_loggerSamp_Idx = Voc_loggerSamp_Idx;
Merged.FS_logger_voc = FS_logger_voc;

Unmerged.Voc_transc_time = Voc_transc_time_unmerged;
Unmerged.LoggerID = LoggerID_unmerged;
Unmerged.Voc_loggerSamp_Idx = Voc_loggerSamp_Idx_unmerged;
Unmerged.FS_logger_voc = FS_logger_voc_unmerged;

fprintf(1,'Done running the detection of sound events using the piezos, %d events were found\n',size(Voc_transc_time,1))
end


%% INTERNAL FUNCTION

function [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir,Date, ExpStartTime,OnOffTranscTime_ms)
TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
FileNum_u = unique(TTL.File_number);

% loop through data
Nevents = size(OnOffTranscTime_ms,1);
MicVoc_samp_idx=nan(Nevents,2);
MicVoc_File = nan(Nevents,1);

% Extract the transceiver time
% zscore the sample stamps
for ff=1:Nevents
    FileNumIdx = find(TTL.Pulse_TimeStamp_Transc<OnOffTranscTime_ms(ff,1),1,'Last');
    if isempty(FileNumIdx)
        FileNumIdx = find(TTL.Pulse_TimeStamp_Transc>OnOffTranscTime_ms(ff,1),1,'First');
    end
    MicVoc_File(ff) = TTL.File_number(FileNumIdx);
    IndFileNum = find(FileNum_u == MicVoc_File(ff));
    TranscTime_zs = (OnOffTranscTime_ms(ff,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(IndFileNum,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(IndFileNum,2);
    MicVoc_samp_idx(ff,:) =round(TTL.Mean_std_Pulse_samp_audio(IndFileNum,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{IndFileNum},TranscTime_zs,[],TTL.Mean_std_x_transc2audiosamp{IndFileNum}) + TTL.Mean_std_Pulse_samp_audio(IndFileNum,1));
end
end

