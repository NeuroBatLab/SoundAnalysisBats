function [] = correctMicAllignment_beforeWhoCalls(RawWav_dir, Date, ExpStartTime)
%% correctMicAllignment_beforeWhoCalls a function to correct the position of
%% Logger detected extracts in continuous microphone recordings
%% for MOTU recordings with vocOperant

% Inputs

% RawWav_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
%  in case calculating microphone time is requested. If left empty, only
%  logger data are calculated. Retrieval of mic data is currently only working for data
% collected with vocOperant (MOTU) and TTL pulses synchronization, and requires running
% align_soundmexAudio_2_logger.m before. Note that if you use microphone
% data, then vocalizations detected on loggers outside of microphone
% recording times will not be kept



if exist(fullfile(RawWav_dir, 'Detected_calls'),'dir')
    Allfiles = fullfile(RawWav_dir, 'Detected_calls',sprintf('*_%s_%s*.wav',Date, ExpStartTime));
    system(sprintf('rm %s',Allfiles));
else
    mkdir(fullfile(RawWav_dir, 'Detected_calls'))
end




%% Load data and initialize output variables
% Load the pulse times and samples
TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));

OldData = load(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time','MeanStdAmpRawExtract','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File');


%% Retrieve the Microphone file that contains the data for each detected sequence of vocalization if requested
% currently only working for Motu set-ups
fprintf(1, '*****  Retrieve corresponding data in the microphone  *****\n')
% Construct the frequency bandpass filter for calculating the noise rate on
% the microphone data
WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*.wav',Date, ExpStartTime)));
Subj = WavFileStruc_local(1).name(1:4);

NRawWave = length(WavFileStruc_local);
MeanStdAmpRawFile = nan(NRawWave,2);
FileIdx = nan(NRawWave,1);

% Retrieve the previously calculated amplitude threshold (the average amplitude on the
% first 30 seconds of that 10 min recording file from which that file
% come from
% Get the average running rms in a Dur_RMS min extract in the middle of
% the recording
% calculate the amplitude threshold for that file
for vv=1:NRawWave
    FileIdx(vv) = vv;
    MeanStdAmpRawFile(vv,:) = OldData.MeanStdAmpRawExtract(find(OldData.MicVoc_File==vv,1, 'First'),:);
end


% convert new corrected transceiver time to audio samp files
[MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir,OldData.Voc_transc_time);
MeanStdAmpRawExtract = MeanStdAmpRawFile(MicVoc_File,:);
TotEvents_merged = size(OldData.Voc_transc_time,1);
Voc_filename = cell(TotEvents_merged,1);
OldMicVoc_File=0;
for ee=1:TotEvents_merged
    fprintf('Saving Voc %d/%d\n', ee, TotEvents_merged)
    
    %         % Extract the wave from the microphone recording
    if any(MicVoc_samp_idx(ee,:)<0)
        % This vocalization happened before the microphone started
        % recording, discard
        fprintf(1,'Vocalization happened before Mic onset\n')
    else
        if ~(MicVoc_File(ee) == OldMicVoc_File)
            WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
            Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
            [Raw_10minwav2, FS2] = audioread(Raw_filename);
        end
        
        if length(Raw_10minwav2)>MicVoc_samp_idx(ee,1)
            Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
        elseif MicVoc_File(ee)==NRawWave
            % This event happened after the offset of microphone, discard
            fprintf(1, 'This call occured after microphone offset\n')
            continue
        else% there was an error in the estimation of the file index, this call occured in the next file
            fprintf(1, 'This call occured in next file\n')
            MicVoc_File(ee) = MicVoc_File(ee)+1;
            MeanStdAmpRawExtract(ee,:)= MeanStdAmpRawFile(MicVoc_File(ee),:)';
            
            % Calculate the Samples of the extract in the microphone recording
            TTL_idx = find(unique(TTL.File_number) == MicVoc_File(ee));
            if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
                continue
            else
                Voc_transc_time_zs = (OldData.Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
                MicVoc_samp_idx(ee,:) = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
            end
            
            if ~(MicVoc_File(ee) == OldMicVoc_File)
                WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                [Raw_10minwav2, FS2] = audioread(Raw_filename);
            end
            Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
        end
        OldMicVoc_File = MicVoc_File(ee);
        
        % Save the sound as a wav file
        Voc_filename{ee} = fullfile(RawWav_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
        audiowrite(Voc_filename{ee} , Raw_wave, FS2)
    end
end

ActiveVoc = ~cellfun('isempty',Voc_filename);
if length(ActiveVoc) ~= TotEvents_merged
    warning('Some vocalizations could not be retrieved\nand the dataset is going to differ from the OldDataset\nWho_calls needs to be restarted from scratch or tweek the files\n')
    keyboard
end
Voc_samp_idx = MicVoc_samp_idx;


%% save and return the calculation results
save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','MeanStdAmpRawExtract','MicVoc_File', '-append')

fprintf(1,'Done correcting the Microphone allignment %d events were found\n',size(Voc_samp_idx,1))
end


%% INTERNAL FUNCTION

function [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir,OnOffTranscTime_ms)
AllFiles = dir(fullfile(RawWav_dir, '*RecOnly*.wav'));
% find the date and expstart time
Date = AllFiles(1).name(6:11);
ExpStartTime = AllFiles(1).name(13:16);
TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));

% loop through data
Nevents = size(OnOffTranscTime_ms,1);
MicVoc_samp_idx=nan(Nevents,2);
MicVoc_File = nan(Nevents,1);

% Extract the transceiver time
% zscore the sample stamps
for ff=1:Nevents
    FileNumIdx = find(TTL.Pulse_TimeStamp_Transc<OnOffTranscTime_ms(ff,1),1,'Last');
    if isempty(FileNumIdx)
        FileNumIdx = find(TTL.Pulse_TimeStamp_Transc>OnOffTranscTime_ms(ff,1),1,'First');
    end
    MicVoc_File(ff) = TTL.File_number(FileNumIdx);
    TranscTime_zs = (OnOffTranscTime_ms(ff,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(MicVoc_File(ff),1))/TTL.Mean_std_Pulse_TimeStamp_Transc(MicVoc_File(ff),2);
    MicVoc_samp_idx(ff,:) =round(TTL.Mean_std_Pulse_samp_audio(MicVoc_File(ff),2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{MicVoc_File(ff)},TranscTime_zs,[],TTL.Mean_std_x_transc2audiosamp{MicVoc_File(ff)}) + TTL.Mean_std_Pulse_samp_audio(MicVoc_File(ff),1));
end
end

