function [Unmerged, Merged] = correctMicAllignment_beforeWhoCalls(Logger_dir,RawWav_dir, Date, ExpStartTime)
%% correctMicAllignment_beforeWhoCalls a function to correct the position of
%% Logger detected extracts in continuous microphone recordings
%% for MOTU recordings with vocOperant

% Inputs
% Logger_dir is the folder containing the logger folders containing the
% extracted/CS0.mat files

% RawWav_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
%  in case calculating microphone time is requested. If left empty, only
%  logger data are calculated. Retrieval of mic data is currently only working for data
% collected with vocOperant (MOTU) and TTL pulses synchronization, and requires running
% align_soundmexAudio_2_logger.m before. Note that if you use microphone
% data, then vocalizations detected on loggers outside of microphone
% recording times will not be kept



if ~exist(fullfile(RawWav_dir, 'Detected_calls'),'dir')
    mkdir(fullfile(RawWav_dir, 'Detected_calls'))
end
FS_raw = 192000;%Frequency of the microphone recordings, here MOTU as default
% Hard coded input for finding the microphone envelope noise threshold
Dur_RMS = 0.5; % duration of the silence sample in min for the calculation of average running RMS
Fhigh_power = 20; %Hz
Fs_env = 1000; %Hz Sample frequency of the enveloppe
Fresample = 40000;% resampling frequency for the calculation of cross correlation between piezo and microphone for better classifying calls
MicThreshNoise = 15*10^-3;



%% Load data and initialize output variables
% Load the pulse times and samples
TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));

OldData = load(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time','MeanStdAmpRawExtract','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File');

%% Merge vocalizations into sequences if they are less than Merge_thresh appart to avoid repetition in Who Calls and add Merge_Thresh before/after
fprintf(1, '***** . Merge sound events within %d ms  *****\n', Merge_thresh)
Events2Merge = [0; (Voc_transc_time_unmerged(2:end,1)-Voc_transc_time_unmerged(1:end-1,2))<= Merge_thresh];
FirstEvents2Merge = find(diff([Events2Merge; 0])==1); % onset of each sequence of events that should be merged
LastEvents2Merge = find(diff([Events2Merge; 0])==-1);% offset of each sequence of events that should be merged
Events2keep = strfind([Events2Merge' 0],[0 0]); % events that should be kept as they are
if length(FirstEvents2Merge)~=length(LastEvents2Merge)
    warning('Problem in the detection of sequences of sound events to merge')
    keyboard
end
Voc_transc_time = [Voc_transc_time_unmerged(Events2keep,:) ; [Voc_transc_time_unmerged(FirstEvents2Merge,1) Voc_transc_time_unmerged(LastEvents2Merge,2)]];
Voc_loggerSamp_Idx = [Voc_loggerSamp_Idx_unmerged(Events2keep,:) ; [Voc_loggerSamp_Idx_unmerged(FirstEvents2Merge,1) Voc_loggerSamp_Idx_unmerged(LastEvents2Merge,2)]];
LoggerID = [LoggerID_unmerged(Events2keep) ; LoggerID_unmerged(FirstEvents2Merge)];
FS_logger_voc = [FS_logger_voc_unmerged(Events2keep) ; FS_logger_voc_unmerged(FirstEvents2Merge)];


% reorder in time
[~, OrdInd] = sort(Voc_transc_time(:,1));
Voc_transc_time = Voc_transc_time(OrdInd,:);
LoggerID = LoggerID(OrdInd);
Voc_loggerSamp_Idx = Voc_loggerSamp_Idx(OrdInd,:);
FS_logger_voc =FS_logger_voc(OrdInd);


% Add MergeThresh before and after each
Voc_transc_time(:,1) = Voc_transc_time(:,1) - Merge_thresh;
Voc_transc_time(:,2) = Voc_transc_time(:,2) + Merge_thresh;
Voc_loggerSamp_Idx(:,1) = Voc_loggerSamp_Idx(:,1) - Merge_thresh*10^-3.*FS_logger_voc;
Voc_loggerSamp_Idx(:,2) = Voc_loggerSamp_Idx(:,2) + Merge_thresh*10^-3.*FS_logger_voc;

TotEvents_merged = size(Voc_transc_time,1);

%% Retrieve the Microphone file that contains the data for each detected sequence of vocalization if requested
% currently only working for Motu set-ups
if MicData
    fprintf(1, '*****  Retrieve corresponding data in the microphone  *****\n')
    % Construct the frequency bandpass filter for calculating the noise rate on
    % the microphone data
    WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*.wav',Date, ExpStartTime)));
    Raw_filename = fullfile(WavFileStruc_local(1).folder, WavFileStruc_local(1).name);
    Subj = WavFileStruc_local(1).name(1:4);
    Info = audioinfo(Raw_filename);
    FS = Info.SampleRate;
    [z,p,k] = butter(6,[1000 90000]/(FS/2),'bandpass');
    sos_raw_band = zp2sos(z,p,k);
    
    NRawWave = length(WavFileStruc_local);
    MeanStdAmpRawFile = cell(1,NRawWave);
    FileIdx = cell(1,NRawWave);
    
    % Calculate the amplitude threshold as the average amplitude on the
    % first 30 seconds of that 10 min recording file from which that file
    % come from
    % Get the average running rms in a Dur_RMS min extract in the middle of
    % the recording
    % calculate the amplitude threshold for that file
    fprintf(1, 'Calculating average RMS values on a %.1f min sample of silence for each mic file\n',Dur_RMS);
    parfor vv=1:NRawWave
        % load the raw file
        Raw_filename = fullfile(WavFileStruc_local(vv).folder, WavFileStruc_local(vv).name);
        [Raw_10minwav, FS] = audioread(Raw_filename);
        
        
        SampleDur = round(Dur_RMS*60*FS);
        StartSamp = round(length(Raw_10minwav)/2);
        fprintf(1,'Calculating the amplitude threshold for file %d/%d  ',vv,NRawWave)
        BadSection = 1;
        while BadSection
            Filt_RawVoc = filtfilt(sos_raw_band,1,Raw_10minwav(StartSamp + (1:round(SampleDur))));
            Amp_env_Mic = running_rms(Filt_RawVoc, FS, Fhigh_power, Fs_env);
            if any(Amp_env_Mic>MicThreshNoise) % there is most likely a vocalization in this sequence look somewhere else!
                StartSamp = StartSamp + SampleDur +1;
            else
                BadSection = 0;
            end
        end
        Ind_ = strfind(WavFileStruc_local(vv).name, '_');
        Ind_ = Ind_(end);
        Indwav = strfind(WavFileStruc_local(vv).name, '.wav');
        FileIdx{vv} = str2double(WavFileStruc_local(vv).name((Ind_+1):(Indwav)));
        MeanStdAmpRawFile{vv} = [mean(Amp_env_Mic); std(Amp_env_Mic)];
        fprintf('-> Done\n')
    end
    MeanStdAmpRawFile = [MeanStdAmpRawFile{[FileIdx{:}]}]';
    
%     MeanStdAmpRawExtract = cell(1,TotEvents_merged);
    Voc_filename = cell(TotEvents_merged,1);
    OldMicVoc_File=0;
    fprintf(1,'Extracting vocalization sequences from microphone and save\n')
    
    % convert transceiver time to audio samp files
    [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir,Voc_transc_time);
    MeanStdAmpRawExtract = MeanStdAmpRawFile(MicVoc_File,:);
    
    for ee=1:TotEvents_merged
        fprintf('Saving Voc %d/%d\n', ee, TotEvents_merged)
        
%         % Find the microphone file
%         OnFile = find(TTL.Pulse_TimeStamp_Transc<Voc_transc_time(ee,1),1,'Last');
%         OffFile = find(TTL.Pulse_TimeStamp_Transc>Voc_transc_time(ee,2),1,'First')-1;
%         if isempty(OnFile)
%             % This event occured before the onset of TTL pulses
%             OnFile =1;
%             OffFile=1;
%         elseif isempty(OffFile)
%             % This event occured after the offset of TTL pulses
%             OffFile = OnFile;
%         end
%         FileIdx_local = min(TTL.File_number(OnFile), TTL.File_number(OffFile));
%         
%         
%         MeanStdAmpRawExtract{ee}= MeanStdAmpRawFile(MicVoc_File(ee),:)';
        
        % Calculate the Samples of the extract in the microphone recording
%         TTL_idx = find(unique(TTL.File_number) == FileIdx_local);
%         if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
%             continue
%         else
%             Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
%             Voc_samp_idx{ee} = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
%         end
        
        % Extract the wave from the microphone recording
        if any(MicVoc_samp_idx(ee,:)<0)
            % This vocalization happened before the microphone started
            % recording, discard
            fprintf(1,'Vocalization happened before Mic onset\n')
        else
            if ~(MicVoc_File(ee) == OldMicVoc_File)
                WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                [Raw_10minwav2, FS2] = audioread(Raw_filename);
            end
            
            if length(Raw_10minwav2)>MicVoc_samp_idx(ee,1)
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
            elseif MicVoc_File(ee)==NRawWave
                % This event happened after the offset of microphone, discard
                fprintf(1, 'This call occured after microphone offset\n')
                continue
            else% there was an error in the estimation of the file index, this call occured in the next file
                fprintf(1, 'This call occured in next file\n')
                MicVoc_File(ee) = MicVoc_File(ee)+1;
                MeanStdAmpRawExtract(ee,:)= MeanStdAmpRawFile(MicVoc_File(ee),:)';
                
                % Calculate the Samples of the extract in the microphone recording
                TTL_idx = find(unique(TTL.File_number) == MicVoc_File(ee));
                if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
                    continue
                else
                    Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
                    MicVoc_samp_idx(ee,:) = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
                end
                
                if ~(MicVoc_File(ee) == OldMicVoc_File)
                    WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('*_%s_%s*mic*_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                    Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                    [Raw_10minwav2, FS2] = audioread(Raw_filename);
                end
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
            end
            OldMicVoc_File = MicVoc_File(ee);
            
            % Save the sound as a wav file
            Voc_filename{ee} = fullfile(RawWav_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
            audiowrite(Voc_filename{ee} , Raw_wave, FS2)
        end
    end
    
    ActiveVoc = ~cellfun('isempty',Voc_filename);
    Voc_samp_idx = MicVoc_samp_idx(ActiveVoc,:);
    MeanStdAmpRawExtract = MeanStdAmpRawExtract(ActiveVoc,:);
    Voc_filename = Voc_filename(ActiveVoc);
    Voc_transc_time = Voc_transc_time(ActiveVoc,:);
    LoggerID = LoggerID(ActiveVoc);
    Voc_loggerSamp_Idx = Voc_loggerSamp_Idx(ActiveVoc,:);
    FS_logger_voc =FS_logger_voc(ActiveVoc,:);
    MicVoc_File = MicVoc_File(ActiveVoc,:);
end

%% save and return the calculation results
if MicData
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time','MeanStdAmpRawExtract','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File')
else
    save(fullfile(Logger_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_transc_time','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged')
end

Merged.Voc_transc_time = Voc_transc_time;
Merged.LoggerID = LoggerID;
Merged.Voc_loggerSamp_Idx = Voc_loggerSamp_Idx;
Merged.FS_logger_voc = FS_logger_voc;

Unmerged.Voc_transc_time = Voc_transc_time_unmerged;
Unmerged.LoggerID = LoggerID_unmerged;
Unmerged.Voc_loggerSamp_Idx = Voc_loggerSamp_Idx_unmerged;
Unmerged.FS_logger_voc = FS_logger_voc_unmerged;

fprintf(1,'Done running the detection of sound events using the piezos, %d events were found\n',size(Voc_transc_time,1))
end


%% INTERNAL FUNCTION

function [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(RawWav_dir,OnOffTranscTime_ms)
AllFiles = dir(fullfile(RawWav_dir, '*RecOnly*.wav'));
% find the date and expstart time
Date = AllFiles(1).name(6:11);
ExpStartTime = AllFiles(1).name(13:16);
TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));

% loop through data
Nevents = size(OnOffTranscTime_ms,1);
MicVoc_samp_idx=nan(Nevents,2);
MicVoc_File = nan(Nevents,1);

% Extract the transceiver time
% zscore the sample stamps
for ff=1:Nevents
    FileNumIdx = find(TTL.Pulse_TimeStamp_Transc<OnOffTranscTime_ms(ff,1),1,'Last');
    if isempty(FileNumIdx)
        FileNumIdx = find(TTL.Pulse_TimeStamp_Transc>OnOffTranscTime_ms(ff,1),1,'First');
    end
    MicVoc_File(ff) = TTL.File_number(FileNumIdx);
    TranscTime_zs = (OnOffTranscTime_ms(ff,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(MicVoc_File(ff),1))/TTL.Mean_std_Pulse_TimeStamp_Transc(MicVoc_File(ff),2);
    MicVoc_samp_idx(ff,:) =TTL.Mean_std_Pulse_samp_audio(MicVoc_File(ff),2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{MicVoc_File(ff)},TranscTime_zs,[],TTL.Mean_std_x_transc2audiosamp{MicVoc_File(ff)}) + TTL.Mean_std_Pulse_samp_audio(MicVoc_File(ff),1);
end
end

