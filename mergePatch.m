function [] = mergePatch(Loggers_dir,Audio_dir, Date, ExpStartTime, varargin)
%% VOC_LOCALIZE_USING_PIEZO a function to detect vocalizations based on threshold crossing in piezo recordings
%% and classification with an SVM trained on a groundtruth dataset
%% This function also retrieves the position of these extracts in continuous microphone recordings
%% for MOTU recordings with vocOperant
%% Depends on SVMModelNoiseVoc.mat in \SoundAnalysisBats\

% Inputs
% Loggers_dir is the folder containing the logger folders containing the
% extracted/CS0.mat files

% Audio_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
%  in case calculating microphone time is requested. If left empty, only
%  logger data are calculated. Retrieval of mic data is currently only working for data
% collected with vocOperant (MOTU) and TTL pulses synchronization, and requires running
% align_soundmexAudio_2_logger.m before. Note that if you use microphone
% data, then vocalizations detected on loggers outside of microphone
% recording times will not be kept


% Ouputs: 2 structures that contain the same fields detailed below. Unmerged: results
% before sound element merge; Merged: results after merge of sound elements
% within Merge_thresh. Merge_thresh is hard coded at 500ms,to facilitate
% the data curation with who calls.

% Voc_loggerSamp_idx is a 2 column vector that gives the onset and offset indices
% of each extract in the original logger recordings (CS0.mat files).

% Voc_transc_time is a 2 column vector that gives the expected onset and offest
% times of each extract in the piezo logger recordings in transceiver time,
% in ms
% same number of lines as Voc_filename.

% Logger_ID is a cell array of the logger# on which each event has been detected. Note that
% after merge of vocalizations, the LoggerID of the first sound event in
% the sequence is taken as a reference.

% FS_logger_voc is a 1 column vector of the true sampling frequency for
% each detected sound element

Debugrerun = 0;
if nargin<2
    MicData=0;
else
    MicData=1;
end


Merge_thresh = 500; % merge thershold in ms for grouping sounds in sequences if they are withinh that delay

% Optional argument: SerialNumber indicate the serial number of the audio
% loggers for which you want to extract data
pnames = {'SerialNumber'};
dflts  = {[]};
[SerialNumber] = internal.stats.parseArgs(pnames,dflts,varargin{:});

if MicData
    if ~exist(fullfile(Audio_dir, 'Detected_calls'),'dir')
        mkdir(fullfile(Audio_dir, 'Detected_calls'))
    end
end

Buffer = 2000; % Let's cut the audio extracts Buffer ms before and after the predicted time according to audio/transceiver allignment to better allign
BandPassFilter = [1000 5000 9000];


%% Load Data of previous calculations
if MicData
    load(fullfile(Audio_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time','MeanStdAmpRawExtract','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File')
    % Load the pulse times and samples
    TTL_dir = dir(fullfile(Audio_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
    TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
    
else
    load(fullfile(Audio_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_transc_time','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged')
end

if Debugrerun
    load(fullfile(Audio_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_transc_time_old', 'Voc_filename_old')
else
    Voc_transc_time_old = Voc_transc_time; % Keep track of the old values to reference to them later, each row should be a unique identification of the sound extract
    Voc_filename_old = Voc_filename;
end
[~,IC] = unique(MicVoc_File);
MeanStdAmpRawFile = MeanStdAmpRawExtract(IC,:);% retrieve the noise threshold of microphone per file

%% Merge vocalizations into sequences if they are less than Merge_thresh appart to avoid repetition in Who Calls and add Merge_Thresh before/after
fprintf(1, '***** . Merge sound events within %d ms  *****\n', Merge_thresh)
Voc_transc_time = Voc_transc_time_unmerged;
Voc_loggerSamp_Idx = Voc_loggerSamp_Idx_unmerged;
LoggerID = LoggerID_unmerged;
FS_logger_voc = FS_logger_voc_unmerged;
ii=1;
while ii<size(Voc_transc_time,1)
    if (Voc_transc_time(ii+1,1)-Voc_transc_time(ii,2))<=Merge_thresh % The next event start before the end+merge_thresh of the current event and needs to be merged
        % take as end of the merge the longer of the 2 events
        [Voc_transc_time(ii,2), IndMaxTime] = max(Voc_transc_time(ii:(ii+1),2));
        Voc_loggerSamp_Idx(ii,2) = Voc_loggerSamp_Idx(ii+IndMaxTime-1,2);% After merging, most of these numbers do not make sense anymore because they refer to different loggers, only the onset does
        
        % supress the next event that has been merged with ii
        Voc_transc_time(ii+1,:)=[];
        Voc_loggerSamp_Idx(ii+1,:) = [];% After merging, most of these numbers do not make sense anymore because they refer to different loggers, only the onset does
        LoggerID(ii+1) = [];% After merging, the ID of the logger is only true for the onset
        FS_logger_voc(ii+1) = [];
    else % The next event is merge_threshold further, let's keep them separate.
        ii=ii+1;
    end
end

% Add MergeThresh before and after each
Voc_transc_time(:,1) = Voc_transc_time(:,1) - Merge_thresh;
Voc_transc_time(:,2) = Voc_transc_time(:,2) + Merge_thresh;
Voc_loggerSamp_Idx(:,1) = Voc_loggerSamp_Idx(:,1) - Merge_thresh*10^-3.*FS_logger_voc;
Voc_loggerSamp_Idx(:,2) = Voc_loggerSamp_Idx(:,2) + Merge_thresh*10^-3.*FS_logger_voc;

TotEvents_merged = size(Voc_transc_time,1);

%% Retrieve the Microphone file that contains the data for each detected sequence of vocalization if requested
% currently only working for Motu set-ups
if MicData
    fprintf(1, '*****  Retrieve corresponding data in the microphone  *****\n')
    WavFileStruc_local = dir(fullfile(Audio_dir, sprintf('*_%s_%s*mic*.wav',Date, ExpStartTime)));
    Subj = WavFileStruc_local(1).name(1:4);
    NRawWave = length(WavFileStruc_local);
    Voc_filename = cell(TotEvents_merged,1);
    OldMicVoc_File=0;
    fprintf(1,'Extracting vocalization sequences from microphone and save\n')
    
    % convert transceiver time to audio samp files
    [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(Audio_dir, Date, ExpStartTime,Voc_transc_time);
    MeanStdAmpRawExtract = MeanStdAmpRawFile(MicVoc_File,:);
    
    for ee=1:TotEvents_merged
        fprintf('Saving Voc %d/%d\n', ee, TotEvents_merged)
        
%         % Find the microphone file
%         OnFile = find(TTL.Pulse_TimeStamp_Transc<Voc_transc_time(ee,1),1,'Last');
%         OffFile = find(TTL.Pulse_TimeStamp_Transc>Voc_transc_time(ee,2),1,'First')-1;
%         if isempty(OnFile)
%             % This event occured before the onset of TTL pulses
%             OnFile =1;
%             OffFile=1;
%         elseif isempty(OffFile)
%             % This event occured after the offset of TTL pulses
%             OffFile = OnFile;
%         end
%         FileIdx_local = min(TTL.File_number(OnFile), TTL.File_number(OffFile));
%         
%         
%         MeanStdAmpRawExtract{ee}= MeanStdAmpRawFile(MicVoc_File(ee),:)';
        
        % Calculate the Samples of the extract in the microphone recording
%         TTL_idx = find(unique(TTL.File_number) == FileIdx_local);
%         if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
%             continue
%         else
%             Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
%             Voc_samp_idx{ee} = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
%         end
        
        % Extract the wave from the microphone recording
        if any(MicVoc_samp_idx(ee,:)<0)
            % This vocalization happened before the microphone started
            % recording, discard
            fprintf(1,'Vocalization happened before Mic onset\n')
        else
            if MicVoc_File(ee) ~= OldMicVoc_File
                Raw_10minwav2 = [];
                WavFileStruc_local = dir(fullfile(Audio_dir, sprintf('*_%s_%s*mic1_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                [Raw_10minwav2, FS2] = audioread(Raw_filename);
                OldMicVoc_File = MicVoc_File(ee);
            end
            
            if length(Raw_10minwav2)>MicVoc_samp_idx(ee,1)
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
                % Save the sound as a wav file
                Voc_filename{ee} = fullfile(Audio_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
                audiowrite(Voc_filename{ee} , Raw_wave, FS2)
            elseif (length(Raw_10minwav2)<=MicVoc_samp_idx(ee,1)) && (MicVoc_File(ee)==NRawWave)
                % This event happened after the offset of microphone, discard
                fprintf(1, 'This call occured after microphone offset\n')
                Raw_wave = [];
                continue
            elseif length(Raw_10minwav2)<=MicVoc_samp_idx(ee,1)
                % there was an error in the estimation of the file index, this call occured in the next file
                fprintf(1, 'This call occured in next file MicVoc_File=%d/%d\n',MicVoc_File(ee)+1,NRawWave)
                MicVoc_File(ee) = MicVoc_File(ee)+1;
                try
                    MeanStdAmpRawExtract(ee,:)= MeanStdAmpRawFile(MicVoc_File(ee),:)';
                catch
                    MeanStdAmpRawExtract(ee,:) = [mean(MeanStdAmpRawFile(:,1)) mean(MeanStdAmpRawFile(:,2))];
                end
                
                % Calculate the Samples of the extract in the microphone recording
                TTL_idx = find(unique(TTL.File_number) == MicVoc_File(ee));
                if isempty(TTL_idx) % There was an error with that TTL file, no allignment possible, no microphone data can be retrieved
                    continue
                else
                    Voc_transc_time_zs = (Voc_transc_time(ee,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2);
                    MicVoc_samp_idx(ee,:) = round((TTL.Mean_std_Pulse_samp_audio(TTL_idx,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{TTL_idx}, Voc_transc_time_zs,[],TTL.Mean_std_x_transc2audiosamp{TTL_idx}) + TTL.Mean_std_Pulse_samp_audio(TTL_idx,1)))';
                end
                
                if MicVoc_File(ee) ~= OldMicVoc_File
                   Raw_10minwav2 = [];
                    WavFileStruc_local = dir(fullfile(Audio_dir, sprintf('*_%s_%s*mic1_%d.wav',Date, ExpStartTime, MicVoc_File(ee))));
                    Raw_filename = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
                    [Raw_10minwav2, FS2] = audioread(Raw_filename);
                    OldMicVoc_File = MicVoc_File(ee);
                end
                Raw_wave = Raw_10minwav2(MicVoc_samp_idx(ee,1) : min(MicVoc_samp_idx(ee,2),length(Raw_10minwav2)));
                % Save the sound as a wav file
                Voc_filename{ee} = fullfile(Audio_dir, 'Detected_calls',sprintf('%s_%s_%s_voc_%d_%d.wav',Subj,Date,ExpStartTime, MicVoc_File(ee), round(MicVoc_samp_idx(ee,1))));
                audiowrite(Voc_filename{ee} , Raw_wave, FS2)
            end
            
        end
    end
    
    ActiveVoc = ~cellfun('isempty',Voc_filename);
    Voc_samp_idx = MicVoc_samp_idx(ActiveVoc,:);
    MeanStdAmpRawExtract = MeanStdAmpRawExtract(ActiveVoc,:);
    Voc_filename = Voc_filename(ActiveVoc);
    Voc_transc_time = Voc_transc_time(ActiveVoc,:);
    LoggerID = LoggerID(ActiveVoc);
    Voc_loggerSamp_Idx = Voc_loggerSamp_Idx(ActiveVoc,:);
    FS_logger_voc =FS_logger_voc(ActiveVoc,:);
    MicVoc_File = MicVoc_File(ActiveVoc,:);
end

%% save and return the calculation results
if MicData
    save(fullfile(Audio_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename', 'Voc_filename_old', 'Voc_samp_idx','Voc_transc_time', 'Voc_transc_time_old', 'MeanStdAmpRawExtract','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged','ActiveVoc','MicVoc_File', '-append')
else
    save(fullfile(Loggers_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_transc_time','Voc_transc_time_old','Voc_loggerSamp_Idx','LoggerID','FS_logger_voc','LoggerID_unmerged','FS_logger_voc_unmerged','Voc_loggerSamp_Idx_unmerged','Voc_transc_time_unmerged', '-append')
end
clear Raw_wave

fprintf(1,'Done running the detection of sound events using the piezos, %d events were found\n',size(Voc_transc_time,1))


%% Get Logger data (same as get_logger_data_voc)
% Load the localization info of vocalization extracts
VocExt=load(fullfile(Audio_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)));
% Get the number of vocalizations
Nvoc_all = length(Voc_filename);

% Get loggers info and initialize output variables
% Get the number of loggers
Logger_dirs = dir(fullfile(Loggers_dir, '*ogger*'));
DirFlags = [Logger_dirs.isdir];
% Extract only those that are directories.
Logger_dirs = Logger_dirs(DirFlags);
NLogger = length(Logger_dirs);
% Identify the type of logger and initialize output variables
LoggerType = cell(NLogger,1);
SerialNumber_of_interest = nan(NLogger,1);
Loggers_serial_number = cell(NLogger,1);
for ll=1:NLogger
    LDir = dir(fullfile(Logger_dirs(ll).folder, Logger_dirs(ll).name, 'extracted_data', '*CSC*.mat'));
    LData = load(fullfile(LDir(1).folder, LDir(1).name), 'logger_type', 'logger_serial_number');
    LoggerType{ll}  = LData.logger_type;
    if isempty(SerialNumber)
        SerialNumber_of_interest(ll) = 1;
    else
        SerialNumber_of_interest(ll) = sum(SerialNumber==str2double(LData.logger_serial_number));
    end
    if strcmp(LoggerType{ll}, 'Audi') && SerialNumber_of_interest(ll)
        Loggers_serial_number{ll} = LData.logger_serial_number;
    end
end


load(fullfile(Loggers_dir, sprintf('%s_%s_VocExtractData1.mat', Date, ExpStartTime)), 'VocMaxNum', 'AudioLogs');
if ~exist('VocMaxNum', 'var')
    VocMaxNum = 1000;
end
if Nvoc_all>VocMaxNum
    Nvocs = [0 VocMaxNum:VocMaxNum:Nvoc_all (floor(Nvoc_all/VocMaxNum)*VocMaxNum+rem(Nvoc_all,VocMaxNum))];
else
    Nvocs = [0 Nvoc_all];
end
Old_vv_list = nan(Nvoc_all,1);

for NVOC_i = 1:(length(Nvocs)-1)
    Voc_i_start = Nvocs(NVOC_i)+1;
    Voc_i_stop = Nvocs(NVOC_i+1);
    Nvoc = Voc_i_stop-Voc_i_start+1;
    Old_vv_out_list = nan(Nvoc,1);
    fprintf('****** Extracting logger data for set %d/%d of %d vocalizations. ******\n', NVOC_i,length(Nvocs)-1, Nvoc);
    % load previous calculations
    Previous = load(fullfile(Loggers_dir, sprintf('%s_%s_VocExtractData%d.mat', Date, ExpStartTime,NVOC_i)), 'Piezo_wave', 'Piezo_FS',  'Raw_wave','FS',  'AudioLogs', 'VocFilename','Voc_transc_time_refined','LoggerType', 'ReAllignment','VocMaxNum');
    FS = Previous.FS;
    %% Initialize variables
    for ll=1:NLogger
        if strcmp(LoggerType{ll}, 'Audi') && SerialNumber_of_interest(ll)
            Piezo_wave.(sprintf('Logger%s', Loggers_serial_number{ll})) = cell(Nvoc,1);
            Piezo_FS.(sprintf('Logger%s', Loggers_serial_number{ll})) = nan(Nvoc,1);
        end
    end
    Raw_wave = cell(Nvoc,1);
    
    %% Extract the audio loggers data that correspond to the vocalizations
    fprintf(1, '*** Extract audio loggers data for each vocalization ***\n');
    for ll=1:length(AudioLogs)
        fprintf(1, 'AL %d/%d\n', ll, length(AudioLogs));
        % load the audio data
        LDir = dir(fullfile(Logger_dirs(AudioLogs(ll)).folder, Logger_dirs(AudioLogs(ll)).name,'extracted_data', '*CSC*.mat'));
        if length(LDir)~=1
            error('There are %d CSC files when there should be only one for this audio logger: %s', length(LDir),Logger_dirs(AudioLogs(ll)).name)
        end
        LData = load(fullfile(LDir(1).folder, LDir(1).name));
        
        
        % loop through vocalizations and extract the snippet of logger and
        % audio data
        for vv=Voc_i_start:Voc_i_stop
            vv_out = vv-Voc_i_start+1;
            fprintf(1, 'Extracting vocalization %d/%d set %d/%d\n', vv, Voc_i_stop,NVOC_i,length(Nvocs)-1);
            
            % Check if the extract is in the list of the ones previously
            % extracted if yes, skip to the next
            Old_VV = find((Voc_transc_time_old(:,1) == Voc_transc_time(vv,1)).*(Voc_transc_time_old(:,2) == Voc_transc_time(vv,2)));
            Old_VV_out = find((Previous.Voc_transc_time_refined(:,1) == Voc_transc_time(vv,1)).*(Previous.Voc_transc_time_refined(:,2) == Voc_transc_time(vv,2)));
            if ~isempty(Old_VV) && ~isempty(Old_VV_out)  % This is the same as previously done, keep the previous values
                fprintf(1, 'Using previous data Old_VV_out:%d\n', Old_VV_out)
                Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = Previous.Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){Old_VV_out};
                Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = Previous.Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(Old_VV_out);
                if ll~=1 % check that our previous registration of Old_VV and Old_VV_out was correct
                    if (Old_vv_list(vv) ~= Old_VV) || Old_vv_out_list(vv_out) ~= Old_VV_out
                        warning('Issues wit vv values registration')
                        keyboard
                    end
                else
                    Old_vv_list(vv) = Old_VV;
                    Old_vv_out_list(vv_out) = Old_VV_out;
                end
            else
                fprintf(1, 'Fetching new extract\n')
                if sum(isnan(Voc_transc_time(vv,:)))==2
                    fprintf(1, 'No Transceiver time for that vocalization\n')
                    Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = NaN;
                    Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = NaN;
                else
                    VocOnset_time = Voc_transc_time(vv,1) - Buffer;
                    VocOffset_time = Voc_transc_time(vv,2) + Buffer;
                    % find the time stamp on the logger that is closest to before
                    % the snippet of sound onset
                    IndTSOn = find(LData.Timestamps_of_first_samples_usec<(VocOnset_time*10^3), 1, 'Last');
                    if isempty(IndTSOn) % the vocalization was produced before the onset of that logger
                        IndTSOn =1;
                    end
                    Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = NaN;
                    Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = NaN;

                    % find the time stamp on the logger that is closest to after
                    % the snippet of sound offset
                    IndTSOff = find(LData.Timestamps_of_first_samples_usec>(VocOffset_time*10^3), 1, 'First');
                    if ~isempty(IndTSOff)
                        % deduct the corresponding onset and offset samples

                        if IndTSOn<=length(LData.Estimated_channelFS_Transceiver) && ~isnan(LData.Estimated_channelFS_Transceiver(IndTSOn))
                            IndSampOn = round(LData.Indices_of_first_and_last_samples(IndTSOn,1) + LData.Estimated_channelFS_Transceiver(IndTSOn)*(10^-6)*(VocOnset_time*10^3 - LData.Timestamps_of_first_samples_usec(IndTSOn)));
                        else
                            IndSampOn = round(LData.Indices_of_first_and_last_samples(IndTSOn,1) + nanmean(LData.Estimated_channelFS_Transceiver)*(10^-6)*(VocOnset_time*10^3 - LData.Timestamps_of_first_samples_usec(IndTSOn)));
                        end
                        if IndTSOff<=length(LData.Estimated_channelFS_Transceiver) && ~isnan(LData.Estimated_channelFS_Transceiver(IndTSOff))
                            IndSampOff = round(LData.Indices_of_first_and_last_samples(IndTSOff,1) - LData.Estimated_channelFS_Transceiver(IndTSOff)*(10^-6)*(LData.Timestamps_of_first_samples_usec(IndTSOff) - VocOffset_time*10^3));
                        else
                            IndSampOff = round(LData.Indices_of_first_and_last_samples(IndTSOff,1) - nanmean(LData.Estimated_channelFS_Transceiver)*(10^-6)*(LData.Timestamps_of_first_samples_usec(IndTSOff) - VocOffset_time*10^3));
                        end
                        if IndSampOff<=IndSampOn
                            IndSampOff = round(LData.Indices_of_first_and_last_samples(IndTSOn,1) + nanmean(LData.Estimated_channelFS_Transceiver)*(10^-6)*(VocOffset_time*10^3 - LData.Timestamps_of_first_samples_usec(IndTSOn)));
                        end
                    else
                        % find the time stamp on the logger that is closest to before
                        % the snippet of sound offset
                        IndTSOff = find(LData.Timestamps_of_first_samples_usec<(VocOffset_time*10^3), 1, 'Last');
                        % this vocalization is in the last recording file
                        % There is no estimation of the sample frequency for that last
                        % file. Let's estimate it as the average of the previous
                        % estimates
                        FS_local = nanmean(LData.Estimated_channelFS_Transceiver);
                        IndSampOn = round(LData.Indices_of_first_and_last_samples(IndTSOn,1) + FS_local*(10^-6)*(VocOnset_time*10^3 - LData.Timestamps_of_first_samples_usec(IndTSOn)));
                        IndSampOff = round(LData.Indices_of_first_and_last_samples(IndTSOff,1) + FS_local*(10^-6)*(VocOffset_time*10^3 - LData.Timestamps_of_first_samples_usec(IndTSOff)));
                    end

                    % extract the data snippet
                    %         Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv} = double(LData.AD_count_int16(IndSampOn:IndSampOff) - mean(LData.AD_count_int16))/std(LData.AD_count_int16);
                    if  strcmp(LoggerID{vv}, sprintf('Logger%s', LData.logger_serial_number))
                        % we can check the values of samples calculated
                        % with the one obtained earlier

                        if ~(IndSampOn<Voc_loggerSamp_Idx(vv,1)) || ~(IndSampOff>Voc_loggerSamp_Idx(vv,1))
                            Voc_loggerSamp_Idx(vv,:)
                            IndSampOff
                            IndSampOn
                            keyboard
                        end
                        if (~(IndSampOff>Voc_loggerSamp_Idx(vv,2))) && (((IndSampOff-IndSampOn)/50000)<0.5) % there is a discrepancy for the offset and this sequence was not obtained after a merge, that's a problem!!
                            Voc_loggerSamp_Idx(vv,:)
                            IndSampOff
                            IndSampOn
                            keyboard
                        end
                    end
                    if IndSampOff<1
                        % the call started and ended before the onset of
                        % the recording
                        warning('The piezo recording of %s started after the end of vocalization %d, no extraction for that logger\n',Logger_dirs(AudioLogs(ll)).name, vv);
                        Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = nan(1,1);
                    elseif IndSampOff<length(LData.AD_count_int16)
                        if IndSampOn>1
                            Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = double(LData.AD_count_int16(IndSampOn:IndSampOff));
                        else % the call started before the onset of the recording
                            warning('The piezo recording of %s started after the begining of vocalization %d, only extracting from the start of piezo recording and pading the begining with NaN\n',Logger_dirs(AudioLogs(ll)).name, vv);
                            Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = [nan(1,1-IndSampOn) double(LData.AD_count_int16(1:IndSampOff))];
                        end
                    elseif IndSampOn<length(LData.AD_count_int16)% The piezo recording ended before the end of the call section requested
                        warning('The piezo recording of %s ended before the end of vocalization %d, only extracting up to the end of piezo recording and pading the rest with NaN\n',Logger_dirs(AudioLogs(ll)).name, vv);
                        Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = [double(LData.AD_count_int16(IndSampOn:end)) nan(1,IndSampOff-length(LData.AD_count_int16))];
                    elseif IndSampOn>length(LData.AD_count_int16)% The piezo recording ended before the end of the call section requested
                        warning('The piezo recording of %s ended before the begining of vocalization %d, no extraction for that logger\n',Logger_dirs(AudioLogs(ll)).name, vv);
                        Piezo_wave.(sprintf('Logger%s', LData.logger_serial_number)){vv_out} = nan(1,1);
                    end
                    if IndTSOff<=length(LData.Estimated_channelFS_Transceiver)
                        Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = nanmean(LData.Estimated_channelFS_Transceiver(IndTSOn:IndTSOff));
                    elseif IndTSOn<=length(LData.Estimated_channelFS_Transceiver)
                        Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = nanmean(LData.Estimated_channelFS_Transceiver(IndTSOn:end));
                    else % vocalization start and ends in the last recording
                        Piezo_FS.(sprintf('Logger%s', LData.logger_serial_number))(vv_out) = nanmean(LData.Estimated_channelFS_Transceiver);
                    end
                end
            end
        end
    end
    clear LData
    
    % Used to be Roughly Identify who is vocalizing and re-adjust the allignement by doing a cross-correlation
    Voc_transc_time_refined = nan(Nvoc,2); % New more accurate time in transceiver time of vocalization onset/offset on loggers in ms
    OnsetAudiosamp = nan(Nvoc,1); % New more accurate onset sample of vocalization on audio logger extracts in Piezo_wave
    OffsetAudiosamp=nan(Nvoc,1); % New more accurate offset sample of vocalization on audio logger extracts in Piezo_wave
    Fns_AL = fieldnames(Piezo_wave);
    
    for vv=Voc_i_start:Voc_i_stop
        vv_out = vv-Voc_i_start+1;
        fprintf(1, 'Saving vocalization in the cell Raw_wave %d/%d set %d/%d\n', vv, Voc_i_stop,NVOC_i,length(Nvocs)-1);
        if ~isnan(Old_vv_out_list(vv_out)) % This is a file that was not changed
            % save the raw wavefrom
            fprintf(1,'Keep same vocalization as previously saved\n')
            Raw_wave{vv_out} = Previous.Raw_wave{Old_vv_out_list(vv_out)};
            
            % Take same previous values
            Voc_transc_time_refined(vv_out,1) = Previous.Voc_transc_time_refined(Old_vv_out_list(vv_out),1); % Keep the same estimate of VocExt.Voc_transc_time(vv,1) in ms
            Voc_transc_time_refined(vv_out,2) = Previous.Voc_transc_time_refined(Old_vv_out_list(vv_out),2); % Keep the same estimate of VocExt.Voc_transc_time(vv,2) in ms
        
        else
            fprintf(1,'Load the new vocalization\n')
            % save the raw wavefrom
            [Raw_wave{vv_out}, FS] = audioread(Voc_filename{vv});
            
            % calculating the portion of data to erase or add in front of the
            % vocalization on the logger recordings.
            TimeDiff_audio = -Buffer .*10^-3; % this should be negative the reference being the vocalization onset -buffer
            OnsetAudiosamp(vv_out) = round(-TimeDiff_audio*Piezo_FS.(Fns_AL{ll})(vv_out)); % This new onset is taking into account the Buffer that was added at the beginning, suppressing it
            OffsetAudiosamp(vv_out) = round(OnsetAudiosamp(vv_out) + length(Piezo_wave.(Fns_AL{ll}){vv_out}) - 2*Buffer*(10^-3)*Piezo_FS.(Fns_AL{ll})(vv_out));
            Voc_transc_time_refined(vv_out,1) =Voc_transc_time(vv,1); % Keep the same estimate of VocExt.Voc_transc_time(vv,1) in ms
            Voc_transc_time_refined(vv_out,2) = Voc_transc_time(vv,2); % Keep the same estimate of VocExt.Voc_transc_time(vv,2) in ms
        end
    end
    
    %% Better cut the audio loggers data that correspond to the vocalizations
    fprintf(1, 'Better cut audio loggers data\n')
    for ll=1:length(AudioLogs)
        fprintf(1,'-Audio %s\n',Fns_AL{ll})
        for vv_out=1:Nvoc
            if (~any(isnan(Piezo_wave.(Fns_AL{ll}){vv_out}))) && (isnan(Old_vv_out_list(vv_out))) % This vocalization exists on loggers and was recently modified
                Piezo_wave.(Fns_AL{ll}){vv_out} = Piezo_wave.(Fns_AL{ll}){vv_out}(OnsetAudiosamp(vv_out):OffsetAudiosamp(vv_out));
            end
        end
    end
    % Save data
    fprintf(1,'Save the Data in %s\n',fullfile(Loggers_dir, sprintf('%s_%s_VocExtractData%d.mat', Date, ExpStartTime,NVOC_i)))
    VocFilename = VocExt.Voc_filename(Voc_i_start:Voc_i_stop);
    % Check the size of variables
    OP = whos('Piezo_wave');
    OW = whos('Raw_wave');
    if ((OP.bytes/10^9)>=2) || ((OW.bytes/10^9)>=2)
        save(fullfile(Loggers_dir, sprintf('%s_%s_VocExtractData%d.mat', Date, ExpStartTime,NVOC_i)), 'Piezo_wave', 'Piezo_FS',  'Raw_wave','FS', 'Old_vv_out_list', 'Old_vv_list', 'BandPassFilter', 'AudioLogs', 'VocFilename','Voc_transc_time_refined','LoggerType','VocMaxNum', '-append','-v7.3');
    else
        save(fullfile(Loggers_dir, sprintf('%s_%s_VocExtractData%d.mat', Date, ExpStartTime,NVOC_i)), 'Piezo_wave', 'Piezo_FS',  'Raw_wave','FS', 'Old_vv_out_list', 'Old_vv_list', 'BandPassFilter', 'AudioLogs', 'VocFilename','Voc_transc_time_refined','LoggerType','VocMaxNum', '-append');
    end
end


end


%% INTERNAL FUNCTION

function [MicVoc_samp_idx,MicVoc_File]=transc_time2micsamp(Audio_dir,Date, ExpStartTime,OnOffTranscTime_ms)
TTL_dir = dir(fullfile(Audio_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
FileNum_u = unique(TTL.File_number);

% loop through data
Nevents = size(OnOffTranscTime_ms,1);
MicVoc_samp_idx=nan(Nevents,2);
MicVoc_File = nan(Nevents,1);

% Extract the transceiver time
% zscore the sample stamps
for ff=1:Nevents
    FileNumIdx = find(TTL.Pulse_TimeStamp_Transc<OnOffTranscTime_ms(ff,1),1,'Last');
    if isempty(FileNumIdx)
        FileNumIdx = find(TTL.Pulse_TimeStamp_Transc>OnOffTranscTime_ms(ff,1),1,'First');
    end
    MicVoc_File(ff) = TTL.File_number(FileNumIdx);
    IndFileNum = find(FileNum_u == MicVoc_File(ff));
    TranscTime_zs = (OnOffTranscTime_ms(ff,:) - TTL.Mean_std_Pulse_TimeStamp_Transc(IndFileNum,1))/TTL.Mean_std_Pulse_TimeStamp_Transc(IndFileNum,2);
    MicVoc_samp_idx(ff,:) =round(TTL.Mean_std_Pulse_samp_audio(IndFileNum,2) .* polyval(TTL.Slope_and_intercept_transc2audiosamp{IndFileNum},TranscTime_zs,[],TTL.Mean_std_x_transc2audiosamp{IndFileNum}) + TTL.Mean_std_Pulse_samp_audio(IndFileNum,1));
end
end

